const hre = require('hardhat');
const { expect } = require('chai');
const ethers = hre.ethers;
const { createStrategy, executeStrategy, finalizeStrategy } = require('../fixtures/StrategyHelper');
const { MAX_UINT_256, ADDRESS_ZERO } = require('../../lib/constants');
const { setupTests } = require('../fixtures/GardenFixture');
const { createGarden } = require('../fixtures/GardenHelper');
const addresses = require('../../lib/addresses');
const { impersonateAddress } = require('../../lib/rpc');

describe('Locking Funds Attack', function () {
  let garden1;
  let signer1;
  let signer2;
  let DAI;
  let WETH;
  let sushiswapPoolIntegration;
  let harvestVaultIntegration;

  beforeEach(async () => {
    ({
      keeper,
      garden1,
      signer1,
      signer2,
      signer3,
      compoundBorrowIntegration,
      compoundLendIntegration,
      sushiswapPoolIntegration,
      harvestVaultIntegration,
    } = await setupTests()());
    DAI = await ethers.getContractAt('IERC20', addresses.tokens.DAI);
    WETH = await ethers.getContractAt('IERC20', addresses.tokens.WETH);
    ethSushiPair = await ethers.getContractAt('IUniswapV2PairB', addresses.sushiswap.pairs.ethsushi);
    ethSushiVault = await ethers.getContractAt('IHarvestVault', addresses.harvest.vaults.fETHSUSHI);
  });

  describe('Strategy locking funds attacks by launching unsupported strategies', function () {
    it.skip('should protect from the attack trying to block funds when pool LP tokens are deposited into a vault as they are not supported for exit (direct trade into reserveAsset) yet', async function () {
      // TODO fix pending
      // Skipped until the feature is implemented as this type of strategy is not supported yet (it is deactivated at UI)
      console.log('Trying create strategy');
      const strategyContract = await createStrategy(
        'lpStack',
        'vote',
        [signer1, signer2, signer3],
        [sushiswapPoolIntegration.address, harvestVaultIntegration.address],
        garden1,
        false,
        [ethSushiPair.address, 0, ethSushiVault.address, 0],
      );
      console.log('Strategy created');
      await executeStrategy(strategyContract);
      console.log('Strategy executed');
      expect(await ethSushiVault.balanceOf(strategyContract.address)).to.be.gt(0);

      console.log('Finalization always reverts because depositVaultOperation tries swap lp tokens to garden tokens');
      //await strategyContract.connect(signer1).sweep(ethSushiPair.address);
      await finalizeStrategy(strategyContract, 0);
      console.log('Strategy finalized');
      expect(await ethSushiPair.balanceOf(strategyContract.address)).to.equal(0);
    });
  });
});
